/**
 * @file ble.hpp
 * @brief BLE top-level singleton wrapper.
 */
#ifndef ELEC_C7222_BLE_H_
#define ELEC_C7222_BLE_H_

#include <functional>
#include <string>
#include <utility>
#include <vector>

#include "attribute_server.hpp"
#include "ble_address.hpp"
#include "ble_error.hpp"
#include "gap.hpp"
#include "non_copyable.hpp"
#include "security_manager.hpp"

namespace c7222 {

/**
 * @class Ble
 * @brief Singleton entry point for BLE configuration and events.
 *
 * This class is the primary facade for BLE stack initialization, configuration,
 * and event routing. It aggregates references to other singleton components
 * (GAP, AttributeServer, SecurityManager) and coordinates their lifecycle.
 *
 * ---
 * ### Singleton Composition
 *
 * The BLE stack is represented by several singletons:
 * - `Gap` manages advertising, connections, and GAP-level events.
 * - `AttributeServer` parses the ATT database and routes GATT operations.
 * - `SecurityManager` configures pairing and handles security events.
 *
 * `Ble` owns pointers to these instances and ensures they are enabled in the
 * correct order. This keeps a single, global view of BLE state in the system.
 *
 * ---
 * ### Context Pointer (Platform-Specific)
 *
 * `EnableAttributeServer(const void* context)` accepts a platform-specific
 * context pointer. On Pico W, this is the compiled ATT database blob
 * (`att_db.h/att_db.c`) generated by BTstack. The context is cached so the
 * ATT database remains valid for the lifetime of the server.
 *
 * This allows `Ble` to remain platform-agnostic while the platform layer
 * interprets the context appropriately.
 *
 * ---
 * ### Profile Databases (ATT/GATT)
 *
 * BLE profiles are represented as an ATT/GATT database (services, characteristics,
 * and descriptors). On the Pico W, this database is required by the Pico BTstack
 * stack and is generated outside of this library (e.g., by the BTstack tooling
 * that produces `att_db.h/att_db.c`). The database is passed into
 * `EnableAttributeServer()` as the context pointer. The `AttributeServer` parses
 * this database into `Service` and `Characteristic` objects for routing and
 * event callbacks.
 *
 * The database blob is treated as immutable and must remain valid for the
 * lifetime of the server because many static attributes reference data inside
 * that blob.
 *
 * ---
 * ### Typical Workflow
 *
 * 1. **Configure security (optional)**:
 *    - Prepare `SecurityManager::SecurityParameters`.
 *    - Call `EnableSecurityManager(params)` if security is required.
 *
 * 2. **Enable Attribute Server**:
 *    - Call `EnableAttributeServer(att_db)` with the compiled ATT database.
 *
 * 3. **Register handlers**:
 *    - Install attribute/characteristic handlers.
 *    - Register SecurityManager event handlers if needed.
 *    - Do this after `EnableAttributeServer()` (so characteristics exist),
 *      and before `TurnOn()` or before initiating any connections.
 *    - Register GAP event handlers immediately after obtaining the `Gap`
 *      instance, also before `TurnOn()`, so early connection/state events
 *      are not missed.
 *
 * ---
 * ### Handler Registration Timing
 *
 * - **GAP handlers:** register as soon as you get `Gap*` (before `TurnOn()`),
 *   because connection and state events can arrive immediately after the
 *   controller powers on.
 * - **Characteristic handlers:** register after `EnableAttributeServer()` so
 *   the parsed `Service`/`Characteristic` objects exist, and before `TurnOn()`
 *   or any connection attempts.
 * - **SecurityManager handlers:** register after enabling SecurityManager and
 *   before pairing can be triggered (typically before `TurnOn()`).
 *
 * ---
 * ### TurnOn/TurnOff Callbacks
 *
 * `SetOnBleStackOnCallback()` is invoked when the stack transitions to
 * `HCI_STATE_WORKING` after `TurnOn()` succeeds. This is the earliest safe
 * moment to start advertising or initiating connections.
 *
 * `SetOnBleStackOffCallback()` is invoked when the stack leaves the working
 * state (e.g., controller power-off or reset). Use it to stop application
 * activity that depends on an active controller.
 *
 * 4. **Turn on BLE**:
 *    - Call `TurnOn()` to initialize the stack and power on the controller.
 *
 * 5. **Dispatch events**:
 *    - The platform layer forwards HCI events into `DispatchBleHciPacket()`.
 *
 * ---
 * ### Example
 *
 * @code
 * auto* ble = c7222::Ble::GetInstance();
 *
 * // Enable Security Manager (optional)
 * c7222::SecurityManager::SecurityParameters params;
 * params.io_capability = c7222::SecurityManager::IoCapability::kNoInputNoOutput;
 * params.authentication =
 *     c7222::SecurityManager::AuthenticationRequirement::kMitmProtection;
 * ble->EnableSecurityManager(params);
 *
 * // Enable the Attribute Server using the compiled ATT DB (BTstack)
 * ble->EnableAttributeServer(att_db);
 *
 * // Start BLE
 * ble->TurnOn();
 * @endcode
 *
 * ---
 * ### BLE Standard Concepts (High-Level)
 *
 * - **GAP** handles discovery, advertising, and connections.
 * - **GATT/ATT** define services, characteristics, and attribute access.
 * - **SM (Security Manager)** handles pairing, authentication, and encryption.
 *
 * `Ble` sits above these roles and routes HCI events to the appropriate
 * subsystem based on their responsibility.
 *
 * ---
 * ### Raspberry Pi Pico (BTstack) Port
 *
 * On Pico W, the platform implementation in
 * `libs/elec_c7222/ble/platform/rpi_pico/`:
 * - Initializes L2CAP and SM as needed.
 * - Registers BTstack HCI event handlers.
 * - Powers on the controller via `hci_power_control(HCI_POWER_ON)`.
 * - Routes HCI events into GAP, AttributeServer, and SecurityManager.
 * - Updates the AttributeServer security cache on `GAP_EVENT_SECURITY_LEVEL`.
 *
 * The `DumpAttributeServerContext()` helper can dump the ATT database using
 * BTstack when HCI logging is enabled.
 */
class Ble : public NonCopyableNonMovable {
   public:
	/**
	 * \name Singleton and Lifecycle
	 * @{
	 */
	/**
	 * @brief Get the singleton instance.
	 */
	static Ble* GetInstance(bool enable_hci_logging = false);
	/** @} */

	/**
	 * \name Subsystem Access
	 * @{
	 */
	/**
	 * @brief Access the underlying GAP instance.
	 */
	Gap* GetGap() {
		return gap_;
	}

	/**
	 * @brief Access the underlying GAP instance (const).
	 */
	const Gap* GetGap() const {
		return gap_;
	}

	/**
	 * @brief Access the underlying Security Manager instance.
	 */
	SecurityManager* GetSecurityManager() {
		return security_manager_;
	}

	/**
	 * @brief Access the underlying Security Manager instance (const).
	 */
	const SecurityManager* GetSecurityManager() const {
		return security_manager_;
	}

	/**
	 * @brief Enable and access the Security Manager instance.
	 *
	 * This mirrors the Attribute Server enable pattern and allows the SM
	 * to be opt-in rather than constructed eagerly.
	 */
	SecurityManager* EnableSecurityManager(const SecurityManager::SecurityParameters& params);

	/**
	 * @brief Enable and access the Attribute Server instance.
	 *
	 * The context is platform-specific. On Pico W it is the BTstack
	 * ATT database blob (att_db).
	 */
	AttributeServer* EnableAttributeServer(const void* context);
	/** @} */

	/**
	 * \name Logging and Diagnostics
	 * @{
	 */
	/**
	 * @brief Enable HCI event logging to stdout (platform-dependent).
	 *
	 * On the Pico W platform, this initializes the BTstack HCI dump target
	 * when logging is enabled in btstack_config.h.
	 */
	void EnableHCILoggingToStdout();

	/**
	 * @brief Disable HCI event logging to stdout (platform-dependent).
	 */
	void DisableHCILoggingToStdout();

	/**
	 * @brief Check whether HCI logging is enabled.
	 */
	bool IsHCILoggingEnabled() const {
		return hci_logging_enabled_;
	}

	/**
	 * @brief Dump the platform attribute server context (platform-dependent).
	 *
	 * On Pico W, this dumps the ATT database attributes via BTstack when
	 * HCI logging is enabled.
	 */
	static void DumpAttributeServerContext();
	/** @} */
	
	/**
	 * \name Attribute Server Access
	 * @{
	 */
	/**
	 * @brief Access the Attribute Server instance.
	 */
	AttributeServer* GetAttributeServer() {
		return attribute_server_;
	}

	/**
	 * @brief Access the Attribute Server instance (const).
	 */
	const AttributeServer* GetAttributeServer() const {
		return attribute_server_;
	}
	/** @} */

	/**
	 * \name Stack State Callbacks
	 * @{
	 */
	/**
	 * @brief Register BLE stack-on callback (HCI_STATE_WORKING).
	 *
	 * @note The callback is invoked when the BLE stack transitions to
	 *       the working state, indicating that BLE operations can proceed.
	 */
	void SetOnBleStackOnCallback(std::function<void()> handler) {
		callback_on_ble_stack_on_ = std::move(handler);
	}

	/**
	 * @brief Register BLE stack-on callback from a function pointer.
	 */
	void SetOnBleStackOnCallback(void (*handler)()) {
		callback_on_ble_stack_on_ = handler;
	}

	/**
	 * @brief Register BLE stack-on callback from an object/member function.
	 */
	template <typename T>
	void SetOnBleStackOnCallback(T* object, void (T::*method)()) {
		callback_on_ble_stack_on_ = std::function<void()>(std::bind(method, object));
	}

	/**
	 * @brief Register BLE stack-on callback from a const object/member function.
	 */
	template <typename T>
	void SetOnBleStackOnCallback(const T* object, void (T::*method)() const) {
		callback_on_ble_stack_on_ = std::function<void()>(std::bind(method, object));
	}

	/**
	 * @brief Register BLE stack-off callback (non-working state).
	 */
	void SetOnBleStackOffCallback(std::function<void()> handler) {
		callback_on_ble_stack_off_ = std::move(handler);
	}

	/**
	 * @brief Register BLE stack-off callback from a function pointer.
	 */
	void SetOnBleStackOffCallback(void (*handler)()) {
		callback_on_ble_stack_off_ = handler;
	}

	/**
	 * @brief Register BLE stack-off callback from an object/member function.
	 */
	template <typename T>
	void SetOnBleStackOffCallback(T* object, void (T::*method)()) {
		callback_on_ble_stack_off_ = std::function<void()>(std::bind(method, object));
	}

	/**
	 * @brief Register BLE stack-off callback from a const object/member function.
	 */
	template <typename T>
	void SetOnBleStackOffCallback(const T* object, void (T::*method)() const) {
		callback_on_ble_stack_off_ = std::function<void()>(std::bind(method, object));
	}
	/** @} */

	/**
	 * \name Stack Control and Event Routing
	 * @{
	 */
	/**
	 * @brief Power on the BLE stack and controller.
	 *
	 * Initializes L2CAP/SM as needed and registers event handlers.
	 */
	BleError TurnOn();
	/**
	 * @brief Power off the BLE stack and controller.
	 */
	void TurnOff();

	/**
	 * @brief Check whether BLE stack is marked as working.
	 */
	bool IsTurnedOn() const {
		return turned_on_;
	}
	/** @} */

	/**
	 * \name GAP Configuration Helpers
	 * @{
	 */
	/**
	 * @brief Set the GAP device name.
	 */
	void SetDeviceName(const std::string& name);

	/**
	 * @brief Set the advertising flags (e.g., general discoverable).
	 */
	void SetAdvertisementFlags(uint8_t flags);

	/**
	 * @brief Add a GAP event handler.
	 */
	void AddGapEventHandler(const Gap::EventHandler& handler) {
		gap_->AddEventHandler(handler);
	}
	/**
	 * @brief Remove a GAP event handler.
	 */
	void RemoveGapEventHandler(const Gap::EventHandler& handler) {
		gap_->RemoveEventHandler(handler);
	}
	/**
	 * @brief Remove all GAP event handlers.
	 */
	void ClearGapEventHandlers() {
		gap_->ClearEventHandlers();
	}

	/**
	 * @brief Set the random device address.
	 */
	void SetRandomAddress(const BleAddress& address) {
		gap_->SetRandomAddress(address);
	}
	/**
	 * @brief Set advertising parameters.
	 */
	void SetAdvertisingParameters(const Gap::AdvertisementParameters& params) {
		gap_->SetAdvertisingParameters(params);
	}
	/**
	 * @brief Set raw advertising data.
	 */
	void SetAdvertisingData(const uint8_t* data, size_t size) {
		gap_->SetAdvertisingData(data, size);
	}
	/**
	 * @brief Set advertising data from a vector.
	 */
	void SetAdvertisingData(const std::vector<uint8_t>& data) {
		gap_->SetAdvertisingData(data);
	}
	/**
	 * @brief Set advertising data from a builder.
	 */
	void SetAdvertisingData(const AdvertisementDataBuilder& data_builder) {
		gap_->SetAdvertisingData(data_builder);
	}
	/**
	 * @brief Set advertising data from the current builder state.
	 */
	void SetAdvertisingData() {
		gap_->SetAdvertisingData();
	}
	/**
	 * @brief Set scan response data.
	 */
	void SetScanResponseData(uint8_t length, const uint8_t* data) {
		gap_->SetScanResponseData(length, data);
	}
	/**
	 * @brief Enable or disable advertising.
	 */
	void EnableAdvertising(bool enabled) {
		gap_->EnableAdvertising(enabled);
	}
	/**
	 * @brief Start advertising.
	 */
	void StartAdvertising() {
		gap_->StartAdvertising();
	}
	/**
	 * @brief Stop advertising.
	 */
	void StopAdvertising() {
		gap_->StopAdvertising();
	}
	/**
	 * @brief Check whether advertising is enabled.
	 */
	bool IsAdvertisingEnabled() const {
		return gap_->IsAdvertisingEnabled();
	}
	/**
	 * @brief Check whether a GAP connection is active.
	 */
	bool IsConnected() const {
		return gap_->IsConnected();
	}
	/**
	 * @brief Request a connection parameter update.
	 */
	BleError RequestConnectionParameterUpdate(ConnectionHandle con_handle,
											  const Gap::PreferredConnectionParameters& params) {
		return gap_->RequestConnectionParameterUpdate(con_handle, params);
	}
	/**
	 * @brief Apply new connection parameters.
	 */
	BleError UpdateConnectionParameters(ConnectionHandle con_handle,
										const Gap::PreferredConnectionParameters& params) {
		return gap_->UpdateConnectionParameters(con_handle, params);
	}
	/**
	 * @brief Read RSSI for an active connection.
	 */
	BleError ReadRssi(ConnectionHandle con_handle) {
		return gap_->ReadRssi(con_handle);
	}
	/**
	 * @brief Disconnect an active connection.
	 */
	BleError Disconnect(ConnectionHandle con_handle) {
		return gap_->Disconnect(con_handle);
	}
	/**
	 * @brief Access the advertising data builder.
	 */
	AdvertisementDataBuilder& GetAdvertisementDataBuilder() {
		return gap_->GetAdvertisementDataBuilder();
	}
	/**
	 * @brief Access the advertising data builder (const).
	 */
	const AdvertisementDataBuilder& GetAdvertisementDataBuilder() const {
		return gap_->GetAdvertisementDataBuilder();
	}
	/** @} */

	/**
	 * \name Security Manager Convenience Wrappers
	 * @{
	 */
	/**
	 * @brief Add a Security Manager event handler.
	 */
	void AddSecurityEventHandler(const SecurityManager::EventHandler& handler) {
		if(security_manager_ != nullptr){
			security_manager_->AddEventHandler(handler);
		}
	}
	/**
	 * @brief Remove a Security Manager event handler.
	 */
	bool RemoveSecurityEventHandler(const SecurityManager::EventHandler& handler) {
		return security_manager_ != nullptr && security_manager_->RemoveEventHandler(handler);
	}
	/**
	 * @brief Add a Security Manager event handler pointer.
	 */
	void AddSecurityEventHandler(const SecurityManager::EventHandler* handler) {
		if(security_manager_ != nullptr){
			security_manager_->AddEventHandler(handler);
		}
	}
	/**
	 * @brief Remove a Security Manager event handler pointer.
	 */
	bool RemoveSecurityEventHandler(const SecurityManager::EventHandler* handler) {
		return security_manager_ != nullptr && security_manager_->RemoveEventHandler(handler);
	}
	/**
	 * @brief Remove all Security Manager event handlers.
	 */
	void ClearSecurityEventHandlers() {
		if(security_manager_ != nullptr) {
			security_manager_->ClearEventHandlers();
		}
	}

	/**
	 * @brief Configure the Security Manager parameters.
	 */
	BleError ConfigureSecurity(const SecurityManager::SecurityParameters& params) {
		return security_manager_ != nullptr ? security_manager_->Configure(params) : BleError::kCommandDisallowed;
	}
	/**
	 * @brief Set Security Manager IO capability.
	 */
	BleError SetSecurityIoCapability(SecurityManager::IoCapability capability) {
		return security_manager_ != nullptr ? security_manager_->SetIoCapability(capability) : BleError::kCommandDisallowed;
	}
	/**
	 * @brief Set Security Manager authentication requirements.
	 */
	BleError SetSecurityAuthenticationRequirements(SecurityManager::AuthenticationRequirement auth) {
		return security_manager_ != nullptr ? security_manager_->SetAuthenticationRequirements(auth) : BleError::kCommandDisallowed;
	}
	/**
	 * @brief Set Security Manager encryption key size range.
	 */
	BleError SetSecurityKeySizeRange(uint8_t min_key_size, uint8_t max_key_size) {
		return security_manager_ != nullptr ? security_manager_->SetEncryptionKeySizeRange(min_key_size, max_key_size) : BleError::kCommandDisallowed;
	}
	/**
	 * @brief Enable or disable bonding in the Security Manager.
	 */
	BleError SetSecurityBondable(bool bondable) {
		return security_manager_ != nullptr ? security_manager_->SetBondable(bondable) : BleError::kCommandDisallowed;
	}
	/**
	 * @brief Enable or disable Secure Connections only mode.
	 */
	BleError SetSecuritySecureConnectionsOnly(bool enabled) {
		return security_manager_ != nullptr ? security_manager_->SetSecureConnectionsOnly(enabled) : BleError::kCommandDisallowed;
	}

	/**
	 * @brief Confirm "Just Works" pairing.
	 */
	BleError ConfirmJustWorks(ConnectionHandle con_handle) {
		return security_manager_ != nullptr ? security_manager_->ConfirmJustWorks(con_handle)
											: BleError::kCommandDisallowed;
	}
	/**
	 * @brief Confirm numeric comparison pairing.
	 */
	BleError ConfirmNumericComparison(ConnectionHandle con_handle, bool accept) {
		return security_manager_ != nullptr ? security_manager_->ConfirmNumericComparison(con_handle, accept)
											: BleError::kCommandDisallowed;
	}
	/**
	 * @brief Provide passkey for keyboard input role.
	 */
	BleError ProvidePasskey(ConnectionHandle con_handle, uint32_t passkey) {
		return security_manager_ != nullptr ? security_manager_->ProvidePasskey(con_handle, passkey)
											: BleError::kCommandDisallowed;
	}
	/**
	 * @brief Request pairing with the peer device.
	 */
	BleError RequestPairing(ConnectionHandle con_handle) {
		return security_manager_ != nullptr ? security_manager_->RequestPairing(con_handle)
											: BleError::kCommandDisallowed;
	}
	/**
	 * @brief Provide an authorization decision.
	 */
	BleError SetAuthorization(ConnectionHandle con_handle, SecurityManager::AuthorizationResult result) {
		return security_manager_ != nullptr ? security_manager_->SetAuthorization(con_handle, result)
											: BleError::kCommandDisallowed;
	}
	/** @} */

	/**
	 * \name Event Routing
	 * @{
	 */
	/**
	 * @brief Dispatch raw HCI packets to GAP/AttributeServer/SecurityManager.
	 */
	virtual BleError DispatchBleHciPacket(uint8_t packet_type,
										  uint8_t channel,
										  const uint8_t* packet_data,
										  uint16_t packet_data_size);
	/** @} */

   private:
	Ble();
	virtual ~Ble();

	/**
	 * @brief Singleton instance storage.
	 */
	static Ble* instance_;

	/**
	 * \name Internal State
	 * @{
	 */
	/**
	 * @brief Device name advertised via GAP.
	 */
	std::string device_name_;
	/**
	 * @brief Advertising flags (GAP).
	 */
	uint8_t advertisement_flags_ = 0;
	/**
	 * @brief Called when BLE stack transitions to working (HCI_STATE_WORKING).
	 */
	std::function<void()> callback_on_ble_stack_on_{};
	/**
	 * @brief Called when BLE stack transitions to non-working state.
	 */
	std::function<void()> callback_on_ble_stack_off_{};
	/**
	 * @brief GAP singleton used for advertising and connections.
	 */
	Gap* gap_ = nullptr;
	/**
	 * @brief Security Manager singleton (optional).
	 */
	SecurityManager* security_manager_ = nullptr;
	/**
	 * @brief Attribute Server singleton (optional).
	 */
	AttributeServer* attribute_server_ = nullptr;
	/**
	 * @brief True when HCI logging is enabled.
	 */
	bool hci_logging_enabled_ = false;
	/**
	 * @brief True when the stack is turned on.
	 */
	bool turned_on_ = false;

	/**
	 * @brief Platform-specific context pointer (e.g., ATT DB on Pico W).
	 */
	void* context_ = nullptr;
	/** @} */

	/**
	 * @brief Ensure SM event handler is registered with the platform.
	 */
	void EnsureSmEventHandlerRegistered();
};

}  // namespace c7222

#endif	// ELEC_C7222_BLE_H_
